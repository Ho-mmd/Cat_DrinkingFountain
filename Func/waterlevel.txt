#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/delay.h>

volatile unsigned char cnt = 0;
volatile unsigned int result1, result2, result3, percent3 = 0;
volatile unsigned int ADC_Result;
volatile unsigned char ADC_Low, ADC_High;

//LED(v)

int main(void) {
	
	cli();

	DDRF = 0x00; //AD input
	DDRB = 0xFF;
	DDRD = 0xFF;	

	TCCR0 = (0<<FOC0) | (1<<WGM00) | (1<<COM01) | (1<<COM00) | (0<<WGM01) | (0<<CS02) | (0<<CS01) | (1<<CS00 ); //PWM

	TIMSK = 0x04;
	TCCR1A = 0x00; 
	TCCR1B = 0x05; //clk select

	TCNT1H = 0xFF; //초기에 overflow 발생시기 당김
	TCNT1L = 0xC0;

	ADMUX = 0x01;
	ADCSRA = 0x83;

	UCSR0C = 0x07;
	UCSR0B = 0x98;

	UBRR0H = 0x00;
	UBRR0L = 0x67;
	sei();
	
	do {
		
	} while (1);

	return 0;
}

ISR(TIMER1_OVF_vect) { 
	cli();

	TCNT1H = 0xFE; //0.02초 (20ms, 50Hz, duty cycle = 5%)
	TCNT1L = 0xC6;

	ADCSRA |= 0x40; // ADC시작 하겠다

	while ((ADCSRA & 0x10) == 0);//플래그 0이면 참이니까 못나옴

	result1 = ADCL;
	result2 = ADCH;
	result3 = result2 * 256 + result1;

	percent3 = result3;

	if ((percent3) < 200)
		PORTB = 0x01;
	else if ((percent3) >= 200 && (percent3) < 300)
		PORTB = 0x03;
	else if ((percent3) >= 300 && (percent3) < 400)
		PORTB = 0x07;
	else if ((percent3) >= 400 && (percent3) < 500)
		PORTB = 0x0F;
	else if ((percent3) >= 500 && (percent3) < 600)
		PORTB = 0x1F;
	else if ((percent3) >= 600 && (percent3) < 700)
		PORTB = 0x3F;
	else if ((percent3) >= 700 && (percent3) < 800)
		PORTB = 0x7F;
	else if ((percent3) >= 800)
		PORTB = 0xFF;

	sei();

}

ISR(SIG_UART0_RECV){ 

	cli(); 

	while((UCSR0A& 0x20)==0); 
	UDR0 = 13; 

	sei();

}
